#Operating System

1. 进程
进程Thread 是 程序运行和资源分配的基本单位，一个程序至少有一个进程，一个进程至少有一个线程，进程在执行过程中占有独立的内存单元，而多个线程共享内存资源，减少切换次数，效率更高。
线程Process 是 进程的实体 是CPU调度和分派的基本单位 它是比进程更小的能独立运行的基本单位
一个进程可以有多个线程，多个线程也可以并发执行。

2. 互斥锁 Mutex exclusion
防止多个线程同时读写某一块内存区域，防止多个线程同时读写某一块内存区域。

3. 信号量 Semaphore
门口挂n把钥匙，进取的人就取一把钥匙，出来时再把钥匙挂回原处，后到的人发现钥匙架空了，就知道必须在门口排队等着了。这种做法叫做信号量，用来保证多个线程不会相互冲突。

它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问次资源的最大线程数量。
mutex是semaphore的一种特殊情况（n = 1)

4. 死锁
在两个或者多个并发进程中，如果每个进程持有某种资源而又等待其他进程释放它或他们现在保持着的资源，在未改变这种状态之前都不能向前推进，这一组进程即产生死锁。通俗地讲就是两个或多个进程无限期阻塞、相互等待的一种状态。

死锁产生的死条件：
- 互斥条件：一个资源一次只能被一个进程使用
- 请求与保持条件： 一个进程因请求资源而阻塞时，对已获得资源保持不放
- 不剥夺条件： 进程获得的资源，在未完全使用完之前，不能强行剥夺
- 循环等待条件： 若干进程之间形成一种头尾相接的环形等待资源关系

5. 进程状态
1） 就绪状态
  进程已获得除处理机以外的所需资源，等待分配处理机资源。
2） 运行状态
  占用处理机资源运行，处于此状态的进程数小于CPU数
3） 阻塞状态
  进程等待某种条件，在条件满足之前无法执行。

  多线程上下切换
  CPU控制权由一个已经正在运行的线程切换到另外一个就绪并等待获取CPU执行权的线程的过程。

6. 分段和分页

分页
1） 基本思想
  用户程序的地址空间被划分成若干固定大小的区域，称为“页”，相应地，内存空间分成若干个物理快，页和块的大小相等。可将用户程序的任一页放在内存的任一块中，实现了离散分配。

2) 分页存储管理的地址机构
  15	12	11			0

15-12 页号P
页号4位 每个作业最多2^4=16页 表示页号从0000～1111，页内位移量的位数表示页的大小，若页内位移量12位，则2的12次方=4k，页内地址从000000000000 ~ 111111111111

3）页表
分页系统中，允许将进程的每一页离散地存储在内存的任一物理块中，为了能在内存中找到每个页面对应的物理块，系统为每个进程建立一张页面映射表，简称页表。*页表的作用是实现从页号到物理块号的地址映射*
0        2    

1       15（F）    

2       14（E）    

3       1  


7. 守护线程
程序运行完毕，jvm会等待非守护线程完成后关闭，但是jvm不会等待守护线程。
Java GC（Garbage Collection，垃圾收集，垃圾回收）机制，是Java与C++/C的主要区别之一，作为Java开发者，一般不需要专门编写内存回收和垃圾清理代码，对内存泄露和溢出的问题，也不需要像C程序员那样战战兢兢。