Web Technology

## HTTP 
*应用层*
HTTP是一个客户端（用户）和服务端（网站）之间请求和应答的标准，通常使用TCP协议。通过使用网络浏览器、网络爬虫或者其它的工具，客户端发起一个HTTP请求到服务器上指定端口（默认80）。我们称客户端为*用户代理程序*(user agent)。应答的服务器上存储着一些资源，比如HTML文件和图像，我们称这个应答服务器为源服务器(origin server。在用户代理和源服务器中间可能存在多个“中间层”，比如代理服务器、网关或者隧道.

### Http和Https区别
	Http协议运行在TCP之上，明文运输，客户端与服务器端都无法验证双方身份；
	Https是身披SSL(Secure Socket Layer)外壳的Http，运行于SSL上，SSL运行于TCP上，是添加了认证和加密机制的HTTP，两者有如下不同：
	1） 端口不同： Http 80 Https 443
	2） 资源消耗： 和HTTP通信相比， Https通信会由于加减密处理消耗更多的CPU和内存资源
	3） 开销：Https通信需要证书，证书需要向机构购买

	Https的加密机制是一种共享密钥加密和公开密钥加密公用的混合加密机制 

## 加密
### 对称加密与非对称加密
对称密钥加密是指加密和解密使用同一个密钥的方式，这种方式存在的最大问题就是*密钥发送问题*，即如何安全地将密钥发给对方；而非对称加密是指使用一对非对称密钥，即公钥和私钥，公钥可以随意发布，但私钥只有自己知道。发送密文的一方使用对方的公钥进行加密处理，对方接收到加密信息后，使用自己的私钥进行解密。

由于非对称加密的方式不需要发送用来解密的私钥，所以可以保证*安全性*；但是和对称加密比起来，它非常的慢，所以我们还是要用对称加密来传送消息，但对称加密所使用的密钥我们可以通过非对称加密的方式发送出去。
## TCP & UDP

TCP 和USP是OSI模型中传输层的协议。
TCP提供可靠的通信传输，而UDP则常被用于让广播和细节控制交给应用的通信传输

UDP (User Datagram Protocol)
*传输层*
UDP 不提供复杂的控制机制，利用IP提供面向无连接的通信服务。并且它是将应用程序发来的数据在收到的那一刻，立刻按照原样发送到网络上的一种机制。

TCP (transmission Control Protocol 传输控制协议) 面向连接的协议，收发数据前，必须和对方建立可靠的链接。一个TCP必须经过三次“对话”才能建立
简单描述简单过程：
1）主机A向主机B发出连接请求数据包：“我想给你发数据，可以吗？”，这是第一次对话；

2）主机B向主机A发送同意连接和要求同步 （同步就是两台主机一个在发送，一个在接收，协调工作）的数据包 ：“可以，你什么时候发？”，这是第二次对话；

3）主机A再发出一个数据包确认主机B的要求同步：“我现在就发，你接着吧！”， 这是第三次对话。

三次“对话”的目的是使*数据包的发送和接收同步*， 经过三次“对话”之后，主机A才向主机B正式发送数据。

### TCP三次握手过程🤝
第一次握手： 主机A（客户端） 向主机B（服务器） Client将标志位SYN置为1，随机产生一个值seq=J，并将该数据包发送给Server，Client进入SYN_SENT状态，等待Server确认。

第二次握手： 主机B 收到主机A 
Server收到数据包后由标志位SYN=1知道Client请求建立连接，Server将标志位SYN和ACK都置为1，ack=J+1，随机产生一个值seq=K，并将该数据包发送给Client以确认连接请求，Server进入SYN_RCVD状态。

第三次握手：
Client收到确认后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给Server，Server检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，Client和Server进入ESTABLISHED状态，完成三次握手，随后Client与Server之间可以开始传输数据了。

三次握手*特点*
没有应用层数据，
SYN标志位只有在TCP建立时才能被置1，握手完成后SYN标志位置0

处在SYNC_RECV的TCP连接称为半连接，并存储在内核的半连接队列中，在内核收到对端发送的ack包时会查找半连接队列，并将符合的requst_sock信息存储到完成三次握手的连接的队列中，然后删除此半连接。

### 为何三次？两次不行吗？
为了防止 *已失效的链接请求报文突然又传送到了服务端*，产生新的连接，因而产生错误。
三次的时候，Server端没有收到来自客户端的确认，则就会知道Client并没有要求建立请求，就不会建立连接。

### 连接可靠性确认
- 数据包校验： 目的是检测数据在传输过程中的任何变化，若校验出包邮错，则丢弃报文段并且不给出相应，发送端超时重发

- 对失序数据包重排序：既然TCP报文段作为IP数据报来传输，而IP数据报的到达可能会失序，因此TCP报文段的到达也可能会失序。TCP将对失序数据进行重新排序，然后才交给应用层；

- 丢弃重复数据：对于重复数据，能够丢弃重复数据；

- 应答机制：当TCP收到发自TCP连接另一端的数据，它将发送一个确认。这个确认不是立即发送，通常将推迟几分之一秒；

- 超时重发：当TCP发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段；

- 流量控制：TCP连接的每一方都有固定大小的缓冲空间。TCP的接收端只允许另一端发送接收端缓冲区所能接纳的数据，这可以防止较快主机致使较慢主机的缓冲区溢出，这就是流量控制。TCP使用的流量控制协议是可变大小的滑动窗口协议。

### 客户端不断进行请求链接会如何？
服务器端会为每个请求创建一个链接，并向其发送确认报文，然后等待客户端确定。

### DDos攻击
客户端向服务端发送请求链接数据包
服务端向客户端发送确认数据包
客户端不向服务端发送确认数据包，服务器一直等待来自客户端的确认，瘫痪疗

### DDos预防 （没有彻底根治方法，除非不使用TCP）

- 限制同时打开SYN半链接数目（处在SYNC_RECV的TCP连接称为半连接）
- 缩短SYN半链接的Time Out时间
- 关闭不必要服务


### TCP四次分手👋
第一次挥手：Client发送一个FIN，用来关闭Client到Server的数据传送，Client进入FIN_WAIT_1状态。
第二次挥手：Server收到FIN后，发送一个ACK给Client，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），Server进入CLOSE_WAIT状态。此时TCP链接处于半关闭状态，即客户端已经没有要发送的数据了，但服务端若发送数据，则客户端仍要接收。
第三次挥手：Server发送一个FIN，用来关闭Server到Client的数据传送，Server进入LAST_ACK状态。
第四次挥手：Client收到FIN后，Client进入TIME_WAIT状态，接着发送一个ACK给Server，确认序号为收到序号+1，Server进入CLOSED状态，完成四次挥手。

*名词解释*
ACK TCP报头的控制位 确认由目的端发出，用它来告诉发送端这个序列号之前的数据段都收到了，确认号为X，则表示前X-1个数据段都收到了，只有当ACK=1时，确认号有效，ACK=0时，无效。

SYN 同步序列号 TCP建立连接时将这个位置1

FIN 发送端完成发送任务位，当TCP完成数据传输需要断开时，提出断开连接的一方将此位置置1

### UDP(User Data Protocol 用户数据报协议)
1. UDP 是一个*非连接*协议，传输数据之前源端和终端不建立连接，当它想传送时就简单地去抓取来自应用程序的数据，并尽可能快地把它扔到网络上。在发送端，UDP传送数据的速度仅仅是受应用程序生成数据的速度、计算机能力和传输宽带的限制。在接收端，UDP把每个信息段放在队列中，应用程序每次从队列中读一个信息段。

2. 由于传输数据不建立连接，因此也就不需要维护连接状态，包括收发状态等，因此一台服务机可同时向多个客户机传输相同的信息（因为不用维护连接状态）

3. UDP信息报标题很短，仅8个字节;相对于TCP20个字节信息报额外开销小

4. UDP尽最大努力交付，即不保证可靠交付，因此主机不需要维持复杂链接状态表

5. “ping”命令的原理就是向对方主机发送UDP数据包，然后对方主机确认收到数据包，ping命令用来探测主机到主机之间是否通信，如果不能ping到某台主机，表明不能和这台主机建立连接。ping命令是使用IP和网络控制信息协议（ICMP），因而没有涉及到任何传输协议和应用程序，它发送icmp回送请求信息给目的主机。

*icmp* 目的主机必须返回ICMP回送应答消息给源主机。如果源主机在一定时间内收到应答，则认为可达。

### TCP和UDP区别 区别
1. TCP基于连接；UDP无连接
2. TCP对系统资源要求高（20字节） UDP少 （8）
3. TCP只支持点对点通信，UDP支持一对一、一对多、多对一、多对多的通信模式；
4. TCP是面向字节流的，UDP是面向报文的；
5. TCP保证数据正确性，UDP可能丢包
6. TCP保证数据顺序，UDP不保证

### TCP的拥塞处理
在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就会变坏，这种情况就叫做*拥塞*。拥塞控制就是 *防止过多的数据注入网络中，这样可以使网络中的路由器或链路不致过载*。注意，拥塞控制和流量控制不同，前者是一个全局性的过程，而后者指点对点通信量的控制。

拥塞控制方法：
1)慢启动：不要一开始就发送大量的数据，先探测一下网络的拥塞程度，也就是说由小到大逐渐增加拥塞窗口的大小;

2）拥塞避免：拥塞避免算法让拥塞窗口缓慢增长，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1，而不是加倍，这样拥塞窗口按线性规律缓慢增长。

3）快重传：快重传要求接收方在收到一个 失序的报文段 后就立即发出 重复确认（为的是使发送方及早知道有报文段没有到达对方）而不要等到自己发送数据时捎带确认。快重传算法规定，发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期。

4）快恢复：
快重传配合使用的还有快恢复算法，当发送方连续收到三个重复确认时，就执行“乘法减小”算法，把ssthresh门限减半，但是接下去并不执行慢开始算法：因为如果网络出现拥塞的话就不会收到好几个重复的确认，所以发送方现在认为网络可能没有出现拥塞。所以此时不执行慢开始算法，而是将cwnd设置为ssthresh的大小，然后执行拥塞避免算法。


## OSI 开放式系统互联通信参考模型 （Open System Interconnection Reference Model）
1）物理层
物理层 在局部局域网上传送数据帧(data frame)，负责管理计算机通信设备和网络媒体互通
原始比特流传输

2） 数据链路层
数据链路层负责*物理寻址*、错误侦测和改错。当表头和表尾被加至数据包时，会形成帧。
【MAC地址】

3）网络层
网络层决定数据的路径选择和转寄，将网络表头（NH）加至数据包，以形成分组。网络表头包含了网络数据
【IP层】

4）传输层 
传输层把传输表头（TH）加至数据以形成数据包。传输表头包含了所使用的协议等发送信息。

5）会话层
会话层 负责在数据传输中设置和维护计算机网络中两台计算机之间的通信

6）表达层
表达层把数据转换为能与接受着系统格式兼容并适合传输的格式

7）应用层
应用层 提供为应用软件而设的接口，以设置与另一应用软件之间的通信。例如：HTTP，HTTPS，FTP……

## TCP/IP
是一个协议簇。里面包括很多协议，UDP是其中一个，之所以命名为TCP/IP协议，因为TCP和IP是其中很重要的协议。
协议簇中包括应用层，传输层，网络层，网络访问层

应用层包括
1） 超文本传输协议HTTP 万维网基本协议
2） 文件传输 FTP简单文件传输协议
3） 远程登录 Telnet 提供远程访问其他主机功能，允许用户登录Internet主机，并在这台主机上执行命令
4） 网络管理 SNMP简单网络管理协议 该协议提供了监控网络设备的方法，以及配置管理，统计信息收集，性能管理及安全感里
5） 域名系统 DNS 该系统用于在Internet中将域名及其公共广播的网络节点转换成IP地址

网络层包括
1） Internet协议(IP);
2) Internet控制信息协议(ICMP);
3) 地址解析协议(ARP);
4) 反向地址解析协议(RARP).



## 端口及服务
21 FTP（文件传输协议）
22 SSH 
Secure Shell（安全外壳协议，简称SSH）是一种加密的网络传输协议，可在不安全的网络中为网络服务提供安全的传输环境。SSH通过在网络中创建安全隧道来实现SSH客户端与服务器之间的连接。虽然任何网络服务都可以通过SSH实现安全传输，SSH最常见的用途是*远程登录系统*，人们通常利用SSH来传输命令行界面和远程执行命令。使用频率最高的场合类Unix系统
23 Telnet（远程登录）服务
25 SMTP（简单邮件传输协议）
53 DNS域名服务器
80 HTTP超文本传输协议
110 POP3邮件协议
443 HTTPS
1080 Sockets
1521 Oracle数据库默认端口

## 私有（保留）地址
- A类：10.0.0.0 - 10.255.255.255
- B类: 172.16.0.0 - 172.31.255.255
- C类： 192.168.0.0 - 192.168.255.255

## IP地址分为哪几类？
A-> 政府
B-> 中等规模公司
C-> 任何需要的人
D-> 组播
E-> 实验/今后所用
[pic ip_class]

## IP地址
网络号标示某个网络，主机号标志在该网络上的一个特定主机。

## 浏览器中输入网址会发生什么？
- 通过DNS查找域名对应的IP地址。此步会依次查找 浏览器缓存、系统缓存、路由器缓存、ISP DNS缓存、根域名服务器；
- 浏览器获得域名对应IP地址后，浏览器向服务器请求建立连接，发起三次握手；
- TCP链接建立起来后，浏览器向IP对应的web服务器发送一个HTTP请求；
- 服务器响应请求，发回网页内容；
- 浏览器解析网页内容；

以百度为例
1. 客户端浏览器通过DNS解析道http://www.baidu.com 的IP地址220.181.27.48，通过这个IP地址找到客户端道服务器的路径，客户端浏览器发起一个HTTP会话到220.161.27.48 ，然后通过TCP进行封装数据包，输入到网络层。
2. 客户端的传输层，把HTTP会话请求分成报文段，添加源和目的端口，如服务器使用80端口监听客户端请求，客户端由系统随机选择一个端口如5000，与服务器进行交换，服务器把响应的请求返回给客户端的5000端口。然后使用IP层的IP地址查找目的端。
3. 客户端的网络层不用关系应用层或者传输层的东西，主要做的是通过*查找路由表*确定如何到达服务器，期间可能经过多个路由器，这些都是由路由器完成。
4. 客户端的链路层，包通过链路层发送到路由器，通过邻居协议查找给定IP地址的MAC地址，然后发送ARP请求查找目的地址，如果得到回应后就可以使用ARP的请求应答交换的IP数据包。现在就可以传输了，然后发送IP数据包到达服务器地址。

## ISP缓存
1. ISP缓存 本身是一种宽带接入提供商给网页批量访问加速的技术。ISP会将当前访问量较大的网页内容放到ISP服务器的缓存中，当有新的用户请求相同内容时，可以直接从缓存中发送相关信息，不必每次都去访问真正的网站，从而加快了不同用户对相同内容的访问速度，同时也能节省网间流量结算成本。

## ARP协议工作过程
每台主机都设有一个ARP高速缓存（ARPcache），里面有本局域网上各主机和路由器的IP地址和硬件地址的映射表，这些都是该主机目前知道的一些地址。
地址解析协议（英语：Address Resolution Protocol，ARP）是通过解析网络层地址来找寻数据链路层地址的一个在网络协议包中极其重要的网络传输协议。
*ARP是网络层协议，工作内容在链路层*
1. 每个主机都会在自己的ARP缓冲区建立一个ARP缓冲区中建立一个ARP列表，以表示IP地址和MAC地址之间的对应关系。
2. 当源主机要发送数据时，首先检查ARP列表中是否有对应IP地址的目的主机的MAC地址，若有，则直接发送数据，若没有，就向本网段的所有主机发送ARP数据包，该数据包包括的内容：源主机IP地址，源主机MAC地址，目的主机的IP地址。
3. 当本网络的所有主机收到该ARP数据包时，首先检查数据包中的IP地址是否是自己的IP地址，若不是，则忽略该数据包，若是，则首先从数据包中取出源主机的IP和MAC地址写入到ARP列表中，若已经存在，则覆盖，然后将自己的MAC地址写入ARP响应包中，告诉源主机自己时它想要找的MAC地址。
4. 源主机收到ARP响应包后，将目的主机的IP和MAC地址写入ARP列表，并利用此信息发送数据，若源主机一直没有收到ARP数据响应包，则ARP查询失败。

## 判读是否为同一局域网
看网络号是否相同。 C类的情况下是前面三位相同

## HTTP协议包括哪些请求？
- GET ： 对服务器资源的简单请求
- POST ： 用于发送包含用户提交数据的请求
- HEAD ： 类似于GET，不过返回的响应中没有具体内容
- DELETE ： 发出一个删除指定文档的请求
- TRACE ： 发送一个请求副本

## IPv6
采用128bit 首部固定为40字节

## GET 和 POST的区别
(1). 从*功能*上讲，GET一般用来从服务器上*获取资源*，POST一般用来*更新服务器上的资源*；

(2). 从REST服务角度上说，GET是*幂等*的，即读取同一个资源，总是得到相同的数据，而POST不是幂等的，因为每次请求对资源的改变并不是相同的；进一步地，GET不会改变服务器上的资源，而POST会对服务器资源进行改变；

(3). 从请求参数形式上看，GET请求的数据会附在URL之后，即将请求数据放置在HTTP报文的 请求头 中，以?分割URL和传输数据，参数之间以&相连。特别地，如果数据是英文字母/数字，原样发送；否则，会将其编码为 application/x-www-form-urlencoded MIME 字符串(如果是空格，转换为+，如果是中文/其他字符，则直接把字符串用BASE64加密，得出如：%E4%BD%A0%E5%A5%BD，其中％XX中的XX为该符号以16进制表示的ASCII)；而POST请求会把提交的数据则放置在是HTTP请求报文的 *请求体* 中。

(4). 就安全性而言，*POST的安全性要比GET的安全性高*，因为GET请求提交的数据将明文出现在URL上，而且POST请求参数则被包装到请求体中，相对更安全。

(5). 从请求的大小看，GET请求的长度受限于浏览器或服务器对URL长度的限制，允许发送的数据量*较小*，而POST请求则是*没有大小*限制的。

## ICMP协议
*网络层*
ICMP是在RFC 792中定义的互联网协议族之一。通常用于返回的错误信息或是分析路由。ICMP错误消息总是包括了源数据并返回给发送者。 ICMP错误消息的例子之一是TTL值过期。

## VPN协议
VPN隧道协议主要有4种：点到点隧道协议PPTP、第二层隧道协议L2TP、网络层隧道协议IPSec以及SOCKS v5协议。其中，PPTP和L2TP工作在数据链路层，IPSec工作在网络层，SOCK v5工作在会话层

## Cookie、Session与Application
	Cookie 和 Session 都是客户端与服务器之间保持状态的解决方案，具体来说，cookie机制采用的是在*客户端*保持状态的方法，session是在*服务器端*保持状态。

### Cookie及其相关API
	Cookie实际上是一小段的文本信息。。客户端请求服务器，如果服务器需要记录该用户状态，就使用response向客户端浏览器颁发一个Cookie，而客户端浏览器会把Cookie保存起来。当浏览器再请求该网站时，浏览器把请求的网址连同该Cookie一同提交给服务器，服务器检查该Cookie，以此来辨认用户状态。服务器还可以根据需要修改Cookie的内容

### Session
　同样地，会话状态也可以保存在服务器端。客户端请求服务器，如果服务器记录该用户状态，就获取Session来保存状态，这时，如果服务器已经为此客户端创建过session，服务器就按照sessionid把这个session检索出来使用；如果客户端请求不包含sessionid，则为此客户端创建一个session并且生成一个与此session相关联的sessionid，并将这个sessionid在本次响应中返回给客户端保存。保存这个sessionid的方式可以采用 cookie机制 ，这样在交互过程中浏览器可以自动的按照规则把这个标识发挥给服务器；若浏览器禁用Cookie的话，可以通过 URL重写机制 将sessionid传回服务器。

### Session 与Cookie对比
实现机制：Session的实现常常依赖于Cookie机制，通过Cookie机制回传SessionID；

大小限制：Cookie有大小限制并且浏览器对每个站点也有cookie的个数限制，Session没有大小限制，理论上只与服务器的内存大小有关；

安全性：Cookie*存在安全隐患*，通过拦截或本地文件找得到cookie后可以进行攻击，而Session由于保存在服务器端，相对更加安全；

服务器资源消耗：Session是保存在服务器端上会存在一段时间才会消失，如果session过多会*增加服务器的压力*。
